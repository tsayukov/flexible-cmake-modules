# Flexible CMake Modules
# ------------------------------------------------------------------------------
# Author: Pavel Tsayukov
# Repository: https://github.com/tsayukov/flexible-cmake-modules
# Distributed under the MIT License. See the accompanying file LICENSE or
# https://opensource.org/license/mit for details.
# ------------------------------------------------------------------------------
#
# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
# FOR COAUTHORS AND CONTRIBUTORS: fill in your name, contacts, and changes above
#
#[=================================================================[#github/wiki
# Install

## Table of Contents:

- [fcm_install](#fcm_install)
  - [Project's Configs](#fcm_install(CONFIGS))
  - [Project's Headers](#fcm_install(HEADERS))
  - [Project's Export Headers](#fcm_install(EXPORT_HEADERS))
  - [Project's Targets](#fcm_install(TARGETS))
  - [Project's License](#fcm_install(LICENSE))
- [fcm_add_component_target](#fcm_add_component_target)

## fcm_install

### fcm_install(CONFIGS)

Generate and install CMake configuration files for using
in a [`find_package()`][301] call.

```
fcm_install(CONFIGS
            [PATH_VARS <path_vars>...]
            [NO_SET_AND_CHECK_MACRO]
            [NO_CHECK_REQUIRED_COMPONENTS_MACRO]
            [VERSION <major.minor.patch>]
            COMPATIBILITY <version_compatibility>
            [ARCH_INDEPENDENT])
```

This command internally make a [`configure_package_config_file()`][302],
[`write_basic_package_version_file()`][303], and [`install(FILES)`][304] calls.
Some of the arguments of those commands may be passed to this command.

`INSTALL_DESTINATION` is always [`INSTALL_CMAKE_DIR`][202] and is also appended
to the `PATH_VARS` list.

`VERSION` is [`PROJECT_VERSION`][305] by default.

`COMPATIBILITY` is either `AnyNewerVersion`, or `SameMajorVersion`, or
`SameMinorVersion`, or `ExactVersion`.

Set `ARCH_INDEPENDENT` for header-only libraries.

Set a `<FCM_PROJECT_TARGET_PREFIX>configs` install component.

### fcm_install(HEADERS)

Install all recognizable headers located in `<base_directories>`
to [`CMAKE_INSTALL_INCLUDEDIR`][307] with respect to directories' structure.

```
fcm_install(HEADERS
            [BASE_DIRS <base_directories>...]
            [PATTERNS <patterns>...])
```

Install all headers (`*.h`, `*.hh`, `*.h++`, `*.hpp`, `*.hxx`, `*.in`, `*.inc`,
and others described in the `PATTERNS` list) located in `<base_directories>`
and their subdirectories recursively to `CMAKE_INSTALL_INCLUDEDIR`.
The directories' structure in the `BASE_DIRS` is copied verbatim
to the destination.

By default, `<base_directories>` contains [`PROJECT_SOURCE_DIR`][306]`/include`.

If one of `<base_directories>` is a relative path, it will be prepended with
`PROJECT_SOURCE_DIR`.

Set a `<FCM_PROJECT_TARGET_PREFIX>headers` install component.

### fcm_install(EXPORT_HEADERS)

Install all recognizable [export headers][101] of project targets that
are not excluded from installation to [`CMAKE_INSTALL_INCLUDEDIR`][307].

```
fcm_install(EXPORT_HEADERS [PATTERNS <patterns>...])
```

Install all export headers (*.h, *.hh, *.h++, *.hpp, *.hxx, *.in, *.inc,
and others described in the `PATTERNS` list) of project targets that
are not excluded from installation. The directories' structure is copied
verbatim to the destination.

Set a `<FCM_PROJECT_TARGET_PREFIX>headers` install component.

### fcm_install(TARGETS)

Install and export `<targets>`, including all project's targets that
are not excluded from installation to specific destinations.

```
fcm_install(TARGETS [<targets>...] [HEADER_ONLY]
            [NAMESPACE <namespace>])
```

The specific destinations:
- RUNTIME DESTINATION: [`CMAKE_INSTALL_BINDIR`][307];
- LIBRARY DESTINATION: [`CMAKE_INSTALL_LIBDIR`][307];
- ARCHIVE DESTINATION: [`CMAKE_INSTALL_LIBDIR`][307];
- INCLUDES DESTINATION: [`CMAKE_INSTALL_INCLUDEDIR`][307].

Generate and install a [`<PACKAGE_EXPORT_TARGET_NAME>.cmake`][203] file.

The `HEADER_ONLY` option is used to exclude installation of other artifacts.
It actually doesn't make headers install, only exports the corresponding
interface libraries as export targets.

By default, export targets' names will be prepended with
`<FCM_PROJECT_TARGET_PREFIX>::` until that prefix is empty. If the other
namespace is needed, pass `<namespace>` after the `NAMESPACE` keyword
(without two colons).

Set a `<FCM_PROJECT_TARGET_PREFIX>runtime`,
`<FCM_PROJECT_TARGET_PREFIX>development`,
and `<FCM_PROJECT_TARGET_PREFIX>configs` install components.

### fcm_install(LICENSE)

Install the license file(s) `<source_license_paths>`
to [`INSTALL_LICENSE_DIR`][201].

```
fcm_install(LICENSE [<source_license_paths>...])
```

By default, `<source_license_paths>` is `LICENSE`
in [`PROJECT_SOURCE_DIR`][306].

## fcm_add_component_target

Add a `install_<component>` custom target for the install `<component>`.
If the custom target already exists, do nothing.

```
fcm_add_component_target(<component>)
```

It can be used in build presets (CMake 3.20+):

```json
{
  "name": "install_docs",
  "displayName": "Install the generated documentation"
  "configurePreset": "<config_preset>",
  "targets": "install_my_project_docs"
}
```

So the command below could run installation of the project documentation:

```bash
cmake --build --preset install_docs
```

[101]: https://github.com/tsayukov/flexible-cmake-modules/wiki/Project-targets#fcm_generate_export_header

[201]: https://github.com/tsayukov/flexible-cmake-modules/wiki/Variables#INSTALL_LICENSE_DIR
[202]: https://github.com/tsayukov/flexible-cmake-modules/wiki/Variables#INSTALL_CMAKE_DIR
[203]: https://github.com/tsayukov/flexible-cmake-modules/wiki/Variables#PACKAGE_EXPORT_TARGET_NAME

[301]: https://cmake.org/cmake/help/latest/command/find_package.html
[302]: https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html#generating-a-package-configuration-file
[303]: https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html#generating-a-package-version-file
[304]: https://cmake.org/cmake/help/latest/command/install.html#files
[305]: https://cmake.org/cmake/help/latest/variable/PROJECT_VERSION.html
[306]: https://cmake.org/cmake/help/latest/variable/PROJECT_SOURCE_DIR.html
[307]: https://cmake.org/cmake/help/latest/module/GNUInstallDirs.html#result-variables

#]=================================================================]#github/wiki

include_guard(GLOBAL)
@FCM_COMMAND_PREFIX@internal_variable_init_guard()

@FCM_COMMAND_PREFIX@enable_if(ENABLE_INSTALL)

# Helper functions for creating config files that can be included by other
# projects to find and use a package.
# See: https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html
include(CMakePackageConfigHelpers)


function(@FCM_COMMAND_PREFIX@install
  mode
)
  if (mode STREQUAL "CONFIGS")
    @FCM_COMMAND_PREFIX@internal_instal_configs(${ARGN})
  elseif (mode STREQUAL "HEADERS")
    @FCM_COMMAND_PREFIX@internal_instal_headers(${ARGN})
  elseif (mode STREQUAL "EXPORT_HEADERS")
    @FCM_COMMAND_PREFIX@internal_instal_export_headers(${ARGN})
  elseif (mode STREQUAL "TARGETS")
    @FCM_COMMAND_PREFIX@internal_instal_targets(${ARGN})
  elseif (mode STREQUAL "LICENSE")
    @FCM_COMMAND_PREFIX@internal_instal_license(${ARGN})
  else()
    message(FATAL_ERROR ${__FCM_DEBUG_CATCH_FATAL_ERROR__}
      "Unknown mode: \"${mode}\". "
      "Only the CONFIGS, HEADERS, EXPORT_HEADERS, TARGETS, and LICENSE modes "
      "are supported."
    )
    return()
  endif()
endfunction()

function(@FCM_COMMAND_PREFIX@internal_instal_configs)
  cmake_parse_arguments(PARSE_ARGV 0 "ARGS"
    "NO_SET_AND_CHECK_MACRO;NO_CHECK_REQUIRED_COMPONENTS_MACRO;ARCH_INDEPENDENT"
    "VERSION;COMPATIBILITY"
    "PATH_VARS"
  )

  list(APPEND ARGS_PATH_VARS "INSTALL_CMAKE_DIR")

  set(no_set_and_check_macro "")
  if (ARGS_NO_SET_AND_CHECK_MACRO)
    set(no_set_and_check_macro "NO_SET_AND_CHECK_MACRO")
  endif()

  set(no_check_required_components_macro "")
  if (ARGS_NO_CHECK_REQUIRED_COMPONENTS_MACRO)
    set(no_check_required_components_macro "NO_CHECK_REQUIRED_COMPONENTS_MACRO")
  endif()

  @FCM_COMMAND_PREFIX@get(PACKAGE_NAME)
  set(config_file "${PACKAGE_NAME}Config.cmake")
  set(config_version_file "${PACKAGE_NAME}ConfigVersion.cmake")

  @FCM_COMMAND_PREFIX@get(INSTALL_CMAKE_DIR)
  configure_package_config_file(
    "${PROJECT_SOURCE_DIR}/cmake/install/Config.cmake.in"
    "${PROJECT_BINARY_DIR}/${config_file}"
    INSTALL_DESTINATION "${INSTALL_CMAKE_DIR}"
    PATH_VARS ${ARGS_PATH_VARS}
    ${no_set_and_check_macro}
    ${no_check_required_components_macro}
  )

  if (NOT DEFINED ARGS_VERSION)
    set(ARGS_VERSION "${PROJECT_VERSION}")
  endif()

  set(arch_independent "")
  if (ARGS_ARCH_INDEPENDENT)
    set(arch_independent "ARCH_INDEPENDENT")
  endif()

  write_basic_package_version_file(
    "${PROJECT_BINARY_DIR}/${config_version_file}"
    VERSION ${ARGS_VERSION}
    COMPATIBILITY ${ARGS_COMPATIBILITY}
    ${arch_independent}
  )

  @FCM_COMMAND_PREFIX@get_project_target_prefix()
  set(configs_component "${FCM_PROJECT_TARGET_PREFIX}configs")
  install(FILES
      "${PROJECT_BINARY_DIR}/${config_file}"
      "${PROJECT_BINARY_DIR}/${config_version_file}"
    DESTINATION "${INSTALL_CMAKE_DIR}"
    COMPONENT ${configs_component}
  )
  @FCM_COMMAND_PREFIX@add_component_target(${configs_component})
endfunction()

function(@FCM_COMMAND_PREFIX@internal_instal_headers)
  cmake_parse_arguments(PARSE_ARGV 0 "ARGS" "" "BASE_DIRS" "PATTERNS")

  if (NOT DEFINED ARGS_BASE_DIRS)
    set(ARGS_BASE_DIRS "include")
  endif()

  set(absolute_base_dirs "")
  foreach (base_dir IN LISTS ARGS_BASE_DIRS)
    if (NOT IS_ABSOLUTE "${base_dir}")
      set(base_dir "${PROJECT_SOURCE_DIR}/${base_dir}")
    endif()
    list(APPEND absolute_base_dirs "${base_dir}/")
  endforeach()

  list(APPEND ARGS_PATTERNS
    "*.h"
    "*.hh"
    "*.h++"
    "*.hpp"
    "*.hxx"
    "*.in"
    "*.inc"
  )
  list(TRANSFORM ARGS_PATTERNS PREPEND "PATTERN;")

  @FCM_COMMAND_PREFIX@get_project_target_prefix()
  set(headers_component "${FCM_PROJECT_TARGET_PREFIX}headers")
  install(DIRECTORY
      ${absolute_base_dirs}
    DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
    COMPONENT ${headers_component}
    FILES_MATCHING ${ARGS_PATTERNS}
  )
  @FCM_COMMAND_PREFIX@add_component_target(${headers_component})
endfunction()

function(@FCM_COMMAND_PREFIX@internal_instal_export_headers)
  cmake_parse_arguments(PARSE_ARGV 0 "ARGS" "" "" "PATTERNS")

  list(APPEND ARGS_PATTERNS
    "*.h"
    "*.hh"
    "*.h++"
    "*.hpp"
    "*.hxx"
    "*.in"
    "*.inc"
  )
  list(TRANSFORM ARGS_PATTERNS PREPEND "PATTERN;")

  set(export_headers_directories "")

  @FCM_COMMAND_PREFIX@get_project_cache_prefix()
  get_property(install_project_targets
    DIRECTORY "${PROJECT_SOURCE_DIR}"
    PROPERTY ${FCM_PROJECT_CACHE_PREFIX}INSTALL_PROJECT_TARGETS
  )
  foreach (target IN LISTS install_project_targets)
    get_target_property(export_header_dir ${target}
      ${FCM_PROJECT_CACHE_PREFIX}EXPORT_HEADER_DIR
    )
    if (export_header_dir)
      list(APPEND export_headers_directories "${export_header_dir}/")
    endif()
  endforeach()

  @FCM_COMMAND_PREFIX@get_project_target_prefix()
  set(headers_component "${FCM_PROJECT_TARGET_PREFIX}headers")
  install(DIRECTORY
      ${export_headers_directories}
    DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
    COMPONENT ${headers_component}
    FILES_MATCHING ${ARGS_PATTERNS}
  )
  @FCM_COMMAND_PREFIX@add_component_target(${headers_component})
endfunction()

function(@FCM_COMMAND_PREFIX@internal_instal_targets)
  cmake_parse_arguments(PARSE_ARGV 0 "ARGS" "HEADER_ONLY" "NAMESPACE" "TARGETS")

  set(target_list "")
  foreach (target IN LISTS ARGS_TARGETS)
    @FCM_COMMAND_PREFIX@get_target(${target} FULL_NAME_TO target)
    if (NOT TARGET ${target})
      message(FATAL_ERROR ${__FCM_DEBUG_CATCH_FATAL_ERROR__}
        "\"${target}\" is not a target."
      )
      return()
    endif()
    list(APPEND target_list ${target})
  endforeach()

  @FCM_COMMAND_PREFIX@get_project_cache_prefix()
  get_property(install_project_targets
    DIRECTORY "${PROJECT_SOURCE_DIR}"
    PROPERTY ${FCM_PROJECT_CACHE_PREFIX}INSTALL_PROJECT_TARGETS
  )
  list(APPEND target_list ${install_project_targets})

  if (NOT target_list)
    message(FATAL_ERROR ${__FCM_DEBUG_CATCH_FATAL_ERROR__}
      "There are no targets to install."
    )
    return()
  endif()

  @FCM_COMMAND_PREFIX@get_project_target_prefix()

  set(artifact_options "")
  if (NOT ARGS_HEADER_ONLY)
    set(runtime_component "${FCM_PROJECT_TARGET_PREFIX}runtime")
    set(development_component "${FCM_PROJECT_TARGET_PREFIX}development")
    list(APPEND artifact_options
      RUNTIME
        DESTINATION "${CMAKE_INSTALL_BINDIR}"
        COMPONENT ${runtime_component}
      LIBRARY
        DESTINATION "${CMAKE_INSTALL_LIBDIR}"
        COMPONENT ${runtime_component}
        NAMELINK_COMPONENT ${development_component}
      ARCHIVE
        DESTINATION "${CMAKE_INSTALL_LIBDIR}"
        COMPONENT ${development_component}
    )
    @FCM_COMMAND_PREFIX@add_component_target(${runtime_component})
    @FCM_COMMAND_PREFIX@add_component_target(${development_component})
  endif()

  @FCM_COMMAND_PREFIX@get(PACKAGE_EXPORT_TARGET_NAME)
  install(TARGETS
      ${target_list}
    EXPORT "${PACKAGE_EXPORT_TARGET_NAME}"
    CONFIGURATIONS "Release"
    ${artifact_options}
    INCLUDES DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
  )

  if (NOT DEFINED ARGS_NAMESPACE)
    if (FCM_PROJECT_TARGET_PREFIX STREQUAL "")
      set(namespace_parameter "")
    else()
      string(REGEX REPLACE "_$" "" ARGS_NAMESPACE "${FCM_PROJECT_TARGET_PREFIX}")
    endif()
  endif()

  if (DEFINED ARGS_NAMESPACE)
    set(namespace_parameter "NAMESPACE" "${ARGS_NAMESPACE}::")
  endif()

  set(configs_component "${FCM_PROJECT_TARGET_PREFIX}configs")
  install(EXPORT
      "${PACKAGE_EXPORT_TARGET_NAME}"
    ${namespace_parameter}
    DESTINATION "${INSTALL_CMAKE_DIR}"
    COMPONENT ${configs_component}
  )
  @FCM_COMMAND_PREFIX@add_component_target(${configs_component})
endfunction()

function(@FCM_COMMAND_PREFIX@internal_instal_license)
  if (ARGC EQUAL "0")
    set(source_license_paths "${PROJECT_SOURCE_DIR}/LICENSE")
  else()
    set(source_license_paths ${ARGV})
  endif()

  @FCM_COMMAND_PREFIX@get(INSTALL_LICENSE_DIR)
  install(FILES
      ${source_license_paths}
    DESTINATION "${INSTALL_LICENSE_DIR}"
  )
endfunction()

function(@FCM_COMMAND_PREFIX@add_component_target
  component
)
  if (NOT TARGET install_${component})
    add_custom_target(install_${component}
      COMMAND
        # `cmake --install` works only in 3.15+
        ${CMAKE_COMMAND} -DCOMPONENT=${component} -P "cmake_install.cmake"
      WORKING_DIRECTORY
        "${PROJECT_BINARY_DIR}"
      COMMENT
        "Installing ${component} component..."
    )
  endif()
endfunction()
